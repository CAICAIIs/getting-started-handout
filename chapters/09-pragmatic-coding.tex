\documentclass[../main.tex]{subfiles}
\begin{document}
\chapter{实用主义编程}

\begin{flushright}
    \emph{自本章开始，笔者默认同学们已经学会了至少一门编程语言的语法。}
\end{flushright}

现在同学们的前置知识已经充分，是时候开始正式走向开发了。

对于一些同学而言，即使他们走向工作岗位或者科研岗位之后，他们写出的代码依然难以阅读，更难以进行长期维护。从某种程度上说，\textbf{代码是写给人看的}，机器只是顺便运行，按理说写成什么样子都可以；但是如果可读性太差的话，估计未来的自己都会抽自己几巴掌——完全看不懂。因此，我们将在这里介绍一下怎么才能真正写出来一些\textbf{真正可以交付}的代码。

\section{写代码的基本素养}\label{sec:code-style}

代码风格（码风）是指代码的书写规范和格式化方式。良好的代码风格可以提高代码的可读性和可维护性，使得其他人（包括未来的自己）能够更容易地理解和修改代码。一般情况下，我们会遵循一些通用的代码风格规范，例如 Google C++ Style Guide 或 PEP 8（Python Enhancement Proposal 8）等。而在团队协作的时候，我们则尽可能保证码风和团队的码风一致。

\subsection{命名和代码风格}

一般情况下，有几个值得注意的点：（不同的语言有着不同的要求，不要把以下内容奉为圭臬，例如Vala就习惯在函数名和左括号之间添加空格。）
\begin{itemize}
  \item \textbf{缩进}：使用空格或制表符进行缩进，通常使用2个空格或4个空格或1个制表符。不要混用空格和制表符。
  \item \textbf{命名}：使用有意义的变量名（\texttt{int user\_count}）和函数（\texttt{calc\_total\_price()}），不要使用单个字母（\texttt{a1}）、过度缩写（\texttt{cal()}）或无意义的名称（\texttt{tmp1}）。同时，使用统一的命名风格，例如大驼峰（CamelCase）、小驼峰（camelCase）、下划线（snake\_case）等。
  \item \textbf{注释}：在代码中添加适当的注释，解释代码的逻辑和意图。注释应该简洁明了，不要过于冗长。同时，注释应该与代码保持同步，避免出现过时的注释。避免使用\texttt{\#if 0}和\texttt{\#endif}来注释代码，这种方式风格很老，现在已经不推荐使用了。
  \item \textbf{空行}：适当使用空行来分隔代码块。通常情况下，在类、函数之间使用一个空行，在逻辑相关的代码块之间使用两个空行；有时候在类、函数之间使用两个空行，而在逻辑相关的代码块之间使用\texttt{\#region}和\texttt{\#endregion}或者类似物来分隔代码块。（这取决于你使用的语言和编辑器）
  \item \textbf{括号}：使用一致的括号风格，例如 K\&R 风格（函数定义的左括号在同一行）或 Allman 风格（函数定义的左括号在新的一行）。注意不要在括号前面添加空格。
  \item \textbf{空格}：在运算符两边添加空格，例如\texttt{a + b}而不是\texttt{a+b}。在逗号、分号等符号后面添加空格，例如\texttt{a, b}而不是\texttt{a,b}。在函数调用时，函数名和左括号之间不添加空格，例如\texttt{func()}而不是\texttt{func ()}。
  \item \textbf{行长度}：尽量保持每行代码的长度在80-120个字符之间，避免过长的行导致代码难以阅读。可以使用换行符或者其他手段来分割长行。如果懒得数，也可以用半个屏幕为换行基准。
  \item \textbf{文件长度}：尽量保持每个文件的长度在1500行以内，避免过长的文件导致代码难以阅读。可以将相关的代码分成多个文件，或者使用模块化的方式来组织代码。
\end{itemize}

我们自己写代码的时候虽然不能强制要求自己遵循某种风格，但是在团队协作中，保持一致的代码风格是非常重要的。我们可以使用一些工具来自动格式化代码，VS Code的C++插件就提供了代码格式化功能，可以通过快捷键（通常是Shift + Alt + F）来自动格式化代码。至于python，我们\texttt{pip install black}，然后\texttt{black .}就可以自动格式化当前目录下的所有python文件了。

不要什么都手动缩进。人类不是打字机，机器比我们人打的整齐十倍甚至九倍。

除了这些以外，不同的岗位也有一些不同的码风需求，例如对于后端而言一个非常常见的差代码：
\begin{verbatim}
    for(int i = 0; i<s.length(); i++){
        if(s[i] == 'a'){
            s[i] = 'b';
        }
    }
\end{verbatim}
以上代码的意图是将字符串中的所有字母a替换为b，但是它的效率非常低下，因为每次替换都需要调用一遍\texttt{s.length()}，而且每次替换都需要重新构建字符串，前端得等半天才能看到结果。而前端也有可能出现类似错误，前端的差代码可能是把SQL语句写进了HTML中，这直接导致了SQL注入漏洞，后端同学估计会直接气炸。

为了规避这些错误，同学们需要在实际项目中不断积累经验，才能写出更好的代码，我就不啰嗦了。

\subsection{注释}

很多人都不喜欢写注释，认为代码本身就应该是自解释的，实则不然。当代码逻辑复杂或者涉及到一些特定的业务逻辑时，注释就显得尤为重要；要是码风再差一点，代码就更不能自解释了。

于是我们赌气一般地写了以下注释：
\begin{verbatim}
    i += 1  # 增加 i 的值
\end{verbatim}

对以上注释，我的看法是不如不写，因为只要是认识 \texttt{+=}的人都知道这行代码的意思，这句话本质上是在重复代码本身，没有什么用处。

因此，注释的原则是：\textbf{注释应该解释代码的意图}，或者说，\textbf{说清楚为什么这么写（在做什么）}而不是“这是什么”。或者举个例子：

\begin{verbatim}
    i += 1 # 跳过表头行，数据从下一行开始
\end{verbatim}

这行注释就比上面的注释有用得多，后续在做代码评审的时候也很容易复现当时的思路。

当然，我们作为汉语使用者不喜欢注释非常正常，因为谁都不喜欢来回切输入法，我也不喜欢大量的写注释。但是对于一些复杂的逻辑，虽然无法要求自己每一行都写注释，但是至少要在关键的地方写注释，例如某个非常复杂的算法，至少也要按照步骤写注释（这一部分是做什么，那一部分是做什么）。

\emph{部分公司做自建库的时候，会强制要求代码中注释达到一定的比例。这本意是好的，但是如果注释的质量不高，反而会导致代码难以阅读。部分人甚至导入数万字的网文来应付了事，这是非常不推荐的。}

\section{防御式编程}

近年来防御式编程已经被解构成一个令人不忍直视的名词，例如向代码中添加大量的逆天处理（例如\texttt{\#define true false}）来防止自己被其他人取代或者被公司裁员。这完全是违背了“防御式编程”的初衷，这个名词来源于防御式驾驶，也就是你永远不知道其他司机会干出什么妨碍你的事来，所以要保持警惕。同理，在编程的时候也要保留着大量的警惕，防止别人或者自己在未来时犯错误；同时也在代码崩溃的时候把本不属于自己的错误优雅地甩锅给别人。

除了最常见的大量\texttt{if-else}以外，我们还可以使用一些其他的手段来更优雅地实现防御式编程，例如使用异常处理机制（try-catch）来捕获错误，或者使用断言（assert）来检查代码的前置条件和后置条件。

\subsection{异常处理}

程序员中经常流传着一首歌曲（尤其是C\#程序员）：“死了都要Try……”\footnote{来自著名歌曲《死了都要爱》}，说明了异常处理机制的重要性。异常处理机制可以帮助我们捕获和处理运行时错误，避免程序崩溃；换句话说，异常处理机制的思路是“晚崩溃，晚挨骂”。

一个经典的C\#异常处理结构如下：
\begin{verbatim}
    try{
        // 可能有毛病的代码
        // 我们甚至可以人造异常
        // 例如throw new Exception("这是一个人造异常");
    }
    catch(Exception e){
        // 出了毛病就执行的代码，例如打印错误信息
    }
    finally{
        // 无论如何都会执行的代码
    }
\end{verbatim}

一般finally可以省略，在其他语言中语法也差不多。一个示例是：
\begin{verbatim}
try:
    user = User.get_by_id(user_id)
except UserNotFoundError:
    logger.error(f"用户{user_id}不存在")
    return {"error": "用户不存在"}
\end{verbatim}

这种代码在查询的时候非常常见，能够有效地防止查到空对象并尽早暴露问题，同时还能防止程序崩溃，防止笨蛋甲方在酒吧点炒饭的时候不停地输入不存在的用户ID导致程序崩溃。

\emph{不要\texttt{except Exception as e: pass}，除非你这个大笨蛋想被运维半夜叫醒。}

\subsection{断言}

断言的意思是“我认为这个应该是对的”，如果不成立就抛出异常。断言通常用于检查代码的前置条件和后置条件，确保代码在运行时满足一定的条件。断言可以帮助我们在开发阶段发现问题，并且在生产环境中也可以用来捕获一些潜在的错误。断言的思路和异常处理的思路是相反的：早崩溃，早开心。

比方说以下代码：

\begin{verbatim}
def divide(a, b):
    return a / b
\end{verbatim}

然后某在酒吧点炒饭的笨蛋甲方输入了0作为第二个参数，导致程序崩溃，然后甲方开骂，乙方只能默默挨骂。

这时候，我们可以使用断言来解决这个问题：
\begin{verbatim}
def divide(a, b):
    assert b != 0, "除数不能为零！"
    return a / b
\end{verbatim}

如果甲方输入了0作为第二个参数，程序就会抛出异常（一个“断言错误”），并且输出“除数不能为零！”的错误信息。这样就可以避免程序崩溃，并且可以更好地定位问题。（甲方估计也不会因为这个错误而开骂了）

这个代码如果用raise来写的话就会变成：
\begin{verbatim}
def divide(a, b):
    if b == 0:
        raise ValueError("除数不能为零！")
    return a / b
\end{verbatim}
raise是Python中手动抛出异常的语句，和C\#的throw很像。上述代码和使用断言的区别有两点：一个是代码量变大了（多了一行，不够优雅），另一个是这个异常抛出的是“值错误”而不是“断言错误”。不过在实际操作中，这两个区别不大，且在查询等需要更多信息的场景中，使用raise会更好一些（生产环境中往往禁用断言，优雅不能当饭吃）。

在C系中，也有这样的断言，包括运行时断言和编译时断言。运行时断言指的是在运行时会检查某些条件是否成立，对编译进程没有影响；编译时断言则是在编译阶段就检查某些条件是否成立，如果不成立直接掐断编译。

下文是一个运行时断言：
\begin{verbatim}
#include <assert.h>
void divide(int a, int b) {
    assert(b != 0 && "除数不能为零！");
    printf("%d\n", a / b);
}
\end{verbatim}

\section{监控程序的运行情况}\label{sec:monitoring}

\subsection{日志}\label{subsec:logging}

日志能够帮助我们记录程序运行时的状态和错误信息，我们在\ref{subsec:debugging}节中提到过的“打日志”调试方式就是一种使用日志的方式。

使用print语句是很初级的一种打日志手段，通常我们还会使用更高级的日志库，例如Python的logging模块或者C++的spdlog库等。这些日志库可以提供更丰富的功能，例如日志级别、日志格式化、日志输出到文件等。使用这些日志库可以让我们的代码更加优雅，同时也能更好地管理日志信息。通常说来，日志有以下几个级别（严重性从低到高）：
\begin{itemize}
  \item \textbf{DEBUG}：调试信息，通常用于开发阶段，记录一些调试信息。
  \item \textbf{INFO}：普通信息，记录一些程序运行的基本信息。
  \item \textbf{WARNING}：警告信息，记录一些可能导致问题的情况，但不影响程序的正常运行。
  \item \textbf{ERROR}：错误信息，记录一些导致程序无法正常运行的错误。（这些错误往往不会导致程序崩溃）
  \item \textbf{CRITICAL}：严重错误信息，记录一些导致程序崩溃的错误。
\end{itemize}

日志通常遵循一定的结构：时间-模块-级别-消息。例如：
\begin{verbatim}
    2025-07-16 14:30:00 [user.py:45] ERROR 用户123登录失败：密码错误
\end{verbatim}

日志的格式化可以使用一些工具来实现，例如Python的logging模块提供了丰富的格式化选项，可以自定义日志的输出格式。

\subsection{其他监控手段}\label{subsec:other-monitoring}

除了日志，我们还可以使用其他的监控手段来监控程序的运行情况，比方说打开任务管理器，查看CPU、GPU、内存等资源的使用情况；或者使用一些性能分析工具，例如Python的cProfile模块、C++的gprof工具等，来分析程序的性能瓶颈；特定领域也有一些特定的性能分析工具，例如TensorBoard等。

一个例子：我们在机器学习相关的课程实验中经常会遇到训练过慢的问题。这个时候，不妨打开任务管理器，重点查看GPU和内存的使用情况。如果GPU使用率很低，要么是代码没有充分利用GPU的计算能力，应该增加并行能力（如提高批量大小）以加快代码运行速度；要么是代码没有在GPU上运行，这时候应该检查代码是否有从CPU到GPU的数据传输等。如果GPU使用率很高，说明代码可能存在性能瓶颈或者数据处理不当的问题，应该降低并行程度（但是一般这很难遇见，毕竟这种情况下可以堆卡）。如果内存使用率很高，说明代码可能存在内存泄漏或者数据处理不当的问题。通过这些信息，我们虽然很难直接定位代码的问题所在，但是也可以得到一些直接或者间接的线索，从而更好地优化代码。

对于一些使用HTTP服务的项目，我们还可以监控服务的请求和相应情况，其中最重要的数据应该是QPS（每秒请求数）和响应时间。如果QPS很低或者降到0，说明服务大概率出现了问题（另一种可能是真没有人使用这个服务）；如果响应时间很高，说明服务可能存在性能瓶颈或者数据处理不当的问题。我们可以使用一些工具来监控服务的请求和响应情况，例如Prometheus、Grafana等。前端的开发人员也可以使用浏览器自带的开发者工具来监控页面的加载时间、资源使用情况等。

\section{常见的代码架构}\label{sec:code-architecture}

在实际的开发中，为了便于组织代码，我们通常会遵循一定的代码架构，而不是把代码这碗面煮成一锅粥或者面疙瘩汤。在这里，我们向大家介绍几个常见的架构：

\subsection{MVC架构}

这可以说是最简单的代码架构之一了。它由三个相对独立但是联系密切的部分组成：模型（Model）、视图（View）和控制器（Controller）。模型负责数据的存储和处理，视图负责展示用户界面，控制器负责处理用户输入、协调模型和视图之间的交互。

举个例子：假设我们在制作一个视觉小说游戏，那么我们的代码架构可以采取以上架构：
\begin{itemize}
  \item 模型：负责存储游戏的状态、角色信息、剧情分支等数据。
  \item 视图：负责展示游戏的界面，包括角色立绘、背景、对话框等。
  \item 控制器：负责处理用户的输入，例如点击选项、输入文本等，并根据用户的选择更新模型和视图。
\end{itemize}

MVC架构的优点是将代码分成了三个相对独立的部分，实现起来非常简单，尤其适用于中小型项目。缺点是三个部分之间虽然有着明确的职责划分且相对独立，但是耦合度仍然较高，如果需要修改某个部分的代码，经常会影响到其他部分的代码（你一改代码，别人都得跟着改），代码的可维护性比较低。

\subsection{MVVM架构}
MVVM（Model-View-ViewModel）架构是一种常用于前端开发的架构，它将视图（View）和业务逻辑（ViewModel）分离开来，从而实现了更好的代码组织和可维护性。MVVM架构通常用于前端框架，例如Vue.js、Angular等。笔者不是前端程序员，对MVVM了解甚少，于是不在这里误人子弟了。感兴趣的同学可以自行查阅相关资料。

\subsection{洋葱架构（干净架构）}

洋葱架构（也叫干净架构）是一种分层的架构，它的“层”之间有着严格的依赖关系。一般而言，洋葱架构分四层，外层依赖内层，但内层对外层一无所知，没有任何依赖。

一个典型的洋葱架构分四层：
\begin{itemize}
    \item \textbf{实体层（Entity Layer）}：最内层，包含业务逻辑和领域模型。它定义了系统的核心业务规则和数据结构。
    \item \textbf{用例层（Use Case Layer）}：第二层，包含应用程序的用例和业务逻辑。它定义了系统的功能和行为，并调用实体层来实现业务逻辑。
    \item \textbf{接口层（Interface Layer）}：第三层，包含与外部系统交互的接口和适配器。它定义了系统的输入和输出，并调用用例层来实现功能。
    \item \textbf{外部层（External Layer）}：最外层，包含与外部系统交互的具体实现，例如数据库、Web服务等。它依赖接口层来实现功能。
\end{itemize}

洋葱架构的优点是将代码分成了四个仅单侧依赖的部分，代码的可维护性和可扩展性都比较高（换UI不用动数据库格式；换数据库不用动业务逻辑）。缺点是实现起来比较复杂，因此比较适用于大型项目。如果同样拿刚刚的视觉小说游戏来举例，那么我们的代码架构可以采取以上架构：
\begin{itemize}
    \item 实体层：定义游戏的状态、角色信息、剧情分支等数据结构。
    \item 用例层：处理游戏的逻辑，例如实现判断玩家的选择、更新游戏状态、计算好感度等方法，但是不关心其他层怎么用这玩意。
    \item 接口层：与外部系统交互，例如接受点击的信息后，调用某个方法、返回某些数据，但不关心这数据具体是Json还是SQL。
    \item 外部层：负责具体的实现。
\end{itemize}
这样，故事脚本永远在最甜的心里，就算明天把Unity改成Godot、把这个立绘换成那个立绘，也只需要替换最外层，里面一点不用动。但是这样既不够直观，也不够简单，反而会让人觉得过于臃肿、没有必要。

但是如果我们要做一个类似于微信的即时通讯软件，那么洋葱架构就非常适合了：
\begin{itemize}
    \item 实体层：定义用户信息、聊天记录等数据结构，别的啥也不干。
    \item 用例层：基于这些数据结构，处理核心的业务逻辑，例如处理好友关系、群成员上限判断、雪花算法、端到端加密策略等，并不关心接口层用这些玩意干什么。
    \item 接口层：使用用例层给出的方法，处理用户输入和输出，例如收到“发送消息”事件$\rightarrow$检查权限$\rightarrow$端到端加密算法$\rightarrow$发送到服务器$\rightarrow$返回“发送成功”事件。它只关心如何使用用例层提供的功能，而不关心其他层具体怎么搞的。
    \item 外部层：负责具体的实现，包括并不限于在手机上、电脑上、车载系统上等不同平台的实现。
\end{itemize}

这样，把聊天核心逻辑（内两层）做成一个独立 SDK，外层壳子可以是微信本体、企业微信、微信 Mac 客户端，甚至车载微信，可移植性非常强。这样拆完，需求变更、团队并行、平台移植都变得像剥洋葱——泪流满面的是甲方，不是程序员。

\subsection{微服务架构}

与以上的架构不同，微服务架构并没有一个非常统一的部分或者层次划分；它的宗旨是将一个大型项目拆成许多小的、独立度极高的服务，使得每个服务都可以独立部署、独立扩展、独立维护。每个服务都可以使用不同的技术栈和编程语言来实现，从而实现了更好的灵活性和可扩展性，适合各类大中小型项目。

微服务架构的核心是API（应用程序编程接口），每个服务都提供一组API供其他服务调用。服务之间通过API进行通信，通常使用HTTP或消息队列等方式。打个比方：一个校园，我们把它拆成了许多服务，例如教务、食堂等；我们学生（也是一个服务）可以调用各种API（例如食堂提供的“吃饭”API、教务提供的“上课”API等）来达到自己的目的。

微服务架构的缺点也很明显：服务之间的通信和协调比较复杂，需要使用一些工具来管理服务的依赖关系和通信（例如通信过多的时候就“暂时不能给你明确的答复”）；另一个问题是服务之间通信的延迟、网络问题会显著降低该架构的性能和可靠性；除此之外，它还有部署复杂、测试困难等问题。

\end{document}